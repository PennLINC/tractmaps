######################################################################################################################
#### PARCELLATE FUNCTIONS ####
######################################################################################################################

# This script contains functions to load a dictionary of cortical maps and parcellate them using the Glasser parcellation.

######################################################################################################################

import os
from neuromaps import images
from neuromaps.parcellate import Parcellater
from scipy import stats as sstats


### Apply Glasser parcellation to cortical maps ###
def glasserize(cortical_maps, zscore = True):
    """
    Parcellate cortical maps using the Glasser parcellation and store the parcellated maps in a dictionary.

    Takes a data dictionary input, loads Glasser parcellation (giftii labels), and uses the Neuromaps Parcellater class which, if
    needed, transforms volumetric MNI space data to fslr surface space (which is what the Glasser parcellation is in). The parcellater's 
    fit_transform method is used to apply the parcellation to the input data (data are automatically converted to fslr surface space).
    Parcellated data are returned as a dictionary.

    Parameters:
    -----------
        cortical_maps (dict): A dictionary of cortical maps to be parcellated. Each entry should contain:
            - 'map': Path to the volumetric data file
            - 'annotation': Tuple of (source, name, space) where space indicates the input data space (e.g. 'MNI152')
        zscore (bool, optional): Whether to z-score the parcellated cortical maps. Defaults to True.

    Returns:
    --------
        dict: A dictionary containing the parcellated maps, with the same keys as the input dictionary.
             Each value contains the parcellated data array.
    """
    
    # # get glasser labels (paths to left and right hemisphere label.gii files, generated by prep_glasser_labels.sh)
    # Find the project root by searching for data/derivatives directory
    script_dir = os.path.dirname(os.path.abspath(__file__))
    current_dir = script_dir
    project_root = None
    while current_dir != os.path.dirname(current_dir):  # Stop at filesystem root
        data_derivatives = os.path.join(current_dir, 'data', 'derivatives')
        if os.path.exists(data_derivatives):
            project_root = current_dir
            break
        current_dir = os.path.dirname(current_dir)
    
    if project_root is None:
        raise FileNotFoundError("Could not find data/derivatives directory. Please ensure the script is run from within the project structure.")
    glasser = [os.path.join(project_root, 'data/derivatives/glasser_parcellation/HCP_MMP_L.label.gii'), # left hemisphere 
               os.path.join(project_root, 'data/derivatives/glasser_parcellation/HCP_MMP_R.label.gii')] # right hemisphere
    
    # create parcellater object
    glasser_parc = Parcellater(parcellation = glasser,
                               space = 'fsLR', # space in which the parcellation is defined
                               resampling_target = 'parcellation') # cortical maps provided later will be resampled to the space + res of the parcellation

    # parcellate input maps
    glasser_maps = {}  
    for map_name, value in cortical_maps.items():
        print(f'Map: {map_name}')
        
        # apply Glasser parcellation to the map
        parcellated_map = glasser_parc.fit_transform(data = value['map'], space = value['annotation'][2])

        # z-score the map if zscore is True
        if zscore:
            parcellated_map = sstats.zscore(parcellated_map, nan_policy = 'omit')

        glasser_maps[f'{map_name}'] = parcellated_map

        # Load non-parcellated maps to compare data shape with parcellated maps
        data = images.load_data(value['map'])
        print(f'Original map shape: {data.shape}, parcellated shape: {parcellated_map.shape}') 

    return glasser_maps
