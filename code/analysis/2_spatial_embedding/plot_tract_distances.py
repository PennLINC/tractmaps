# -------------------------------------------------------------
# Plot Glasser region coordinates and Euclidean distances
# -------------------------------------------------------------
# Loads coordinates and precomputed Euclidean distances from
# data_prep/tract_euc_distance.py outputs and creates:
# - Region coordinates heatmap
# - Euclidean distance heatmaps with tract-specific overlays
# -------------------------------------------------------------


# ------------------------------------------------------------------------------------------------
# --- Load packages ---
# ------------------------------------------------------------------------------------------------

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import sys
from pathlib import Path
project_root = Path(__file__).parent.parent.parent
sys.path.append(str(project_root))
from utils import tm_utils
from matplotlib.colors import ListedColormap
plt.switch_backend('Agg')

# ------------------------------------------------------------------------------------------------
# --- Set inputs and outputs ---
# ------------------------------------------------------------------------------------------------

# Paths
root = '/Users/joelleba/PennLINC/tractmaps'
deriv = f'{root}/data/derivatives'
results = f'{root}/results/spatial_embedding'

# Tracts to plot (left hemisphere)
tracts_for_maps = ['IFOF_left', 'VOF_left']

os.makedirs(results, exist_ok=True)

# Inputs generated by data_prep/tract_euc_distance.py
coords_csv = f'{deriv}/glasser_parcellation/glasser_coords.csv'
euc_npy = f'{deriv}/tracts/tracts_distances/euclidean_distances.npy'

# Load data
coords = pd.read_csv(coords_csv)
xyz = coords[['x-cog', 'y-cog', 'z-cog']].to_numpy()

# load euclidean distances
euclidean = np.load(euc_npy)
# select only first 100 regions
euclidean = euclidean[:180, :180]

# load tract probabilities
tracts_csv = f'{deriv}/tracts/tracts_probabilities/tracts_probabilities.csv'
tracts_df = pd.read_csv(tracts_csv)

# load tract pairwise distances
pairwise_csv = f"{deriv}/tracts/tracts_distances/tract_euclidean_distances_pairwise.csv"

# -------------------------------------------------------------
# Plot region XYZ coordinates
# -------------------------------------------------------------

# Get custom colormap
warm_cmap, tract_cmap, categ_warm, cool_warm_cmap, categ_cool_warm, bppy_cmap = tm_utils.make_colormaps()

# Build a 256-length reversed ListedColormap to satisfy tm_utils expectations
bppy_base = bppy_cmap.reversed()
colors = np.vstack([np.array(bppy_base(i)[:3]) for i in np.linspace(0, 1, 256)])
bppy_cmap = ListedColormap(colors)

# show the regions x coordinates matrix
regions_coords = coords[['x-cog', 'y-cog', 'z-cog']].to_numpy()

# select the first 6 rows
regions_coords = regions_coords[:6, :]

plt.figure(figsize=(3.5, 2.8), dpi=300)
sns.heatmap(
    regions_coords,
    annot=False,
    cmap=cool_warm_cmap,
    linecolor='white', linewidths=2,
    square=True,
    xticklabels=False, yticklabels=False,
    cbar=False,
)
plt.tight_layout()
plt.savefig(f"{results}/region_xyz_coords.svg", bbox_inches='tight', dpi=300)
plt.close()
print(f"Saved: {results}/region_xyz_coords.svg")

# -------------------------------------------------------------
# Plot Euclidean distances matrix
# -------------------------------------------------------------

# Render full matrix; avoid heavy white grid covering cells
plt.figure(figsize=(4, 4), dpi=300)
sns.heatmap(
    euclidean,
    annot=False,
    cmap=cool_warm_cmap,
    linecolor=None, linewidths=0,
    square=True,
    xticklabels=False, yticklabels=False,
    cbar=False,
)
plt.tight_layout()
plt.savefig(f"{results}/region_euclidean_distances.svg", bbox_inches='tight', dpi=300)
plt.close()
print(f"Saved: {results}/region_euclidean_distances.svg")

# ------------------------------------------------------------------------------------------------
# Create Euclidean distance colorbar
# ------------------------------------------------------------------------------------------------

fig_cbar, ax_cbar = plt.subplots(figsize=(8, 0.6), dpi=300)
sm = plt.cm.ScalarMappable(cmap=cool_warm_cmap)
sm.set_clim(np.nanmin(euclidean), np.nanmax(euclidean))
sm.set_array([])
cbar = fig_cbar.colorbar(sm, cax=ax_cbar, orientation='horizontal')
cbar.set_label('Euclidean distance (mm)', labelpad=8, fontsize=18)
cbar.ax.tick_params(labelsize=18)
cbar.outline.set_visible(False)
plt.tight_layout()

out_cbar = f"{results}/euclidean_distance_colorbar.svg"
plt.savefig(out_cbar, bbox_inches='tight', dpi=300)
plt.close()
print(f"Saved: {out_cbar}")

# ------------------------------------------------------------------------------------------------
# Upper-triangle Euclidean distances for regions connected to selected tracts
# ------------------------------------------------------------------------------------------------

# Connectivity threshold
conn_thresh = 0.5

for tract in tracts_for_maps:
    # Get regions connected to this tract
    connected = (tracts_df[tract].values >= conn_thresh)
    print(f"Number of regions connected to {tract}: {np.sum(connected)}")

    # Get indices of connected regions
    connected_indices = np.where(connected)[0]
    n_connected = len(connected_indices)
    
    if n_connected > 1:
        # Extract euclidean distances for connected regions only
        connected_euclidean = euclidean[np.ix_(connected_indices, connected_indices)]
        
        # Create upper triangle mask for the smaller matrix (excluding the diagonal)
        connected_upper_mask = np.triu(np.ones((n_connected, n_connected), dtype=bool), k=1)
        connected_lower_mask = ~connected_upper_mask
        
        plt.figure(figsize=(5.0, 5.0), dpi=300)
        sns.heatmap(
            connected_euclidean,
            mask=connected_lower_mask,
            cmap=cool_warm_cmap,
            vmin=np.nanmin(connected_euclidean), vmax=np.nanmax(connected_euclidean),
            square=True,
            xticklabels=False, yticklabels=False,
            cbar=False,
            linewidths=0,
            linecolor=None,
        )
        plt.tight_layout()
        out_path = f"{results}/region_euclidean_upper_{tract}.svg"
        plt.savefig(out_path, bbox_inches='tight', dpi=300)
        plt.close()
        print(f"Saved: {out_path}")
    else:
        print(f"Tract {tract} has {n_connected} connected regions - skipping connected-only plot")





